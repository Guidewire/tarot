package com.guidewire.tarot.sim

import scala.language.postfixOps
import org.joda.time.{DateTime, Interval}

import com.guidewire.tarot.{Config, UID}
import java.util.concurrent.atomic.AtomicInteger

/**  Simulates inbound suites.
  *
  *  Generates suites to be used in [[sim.SimulationStepView$]] to
  *  add to its simulation [[Tracker]].
  */
class SeriesSuiteGenerator (config: Config, applicableSuiteKind: UID[_], series:Iterable[Int])
  extends SuiteGenerator
  with    InjectableSuiteGenerator
{

  private[this] val lock = new java.util.concurrent.locks.ReentrantLock()
  private[this] var iterator:Iterator[Int] = null
  private[this] val uid = applicableSuiteKind
  private[this] val injected_suite_count = new AtomicInteger(0)

  def injectAdditionalSimulatedSuites(suiteKind: UID[_], count: Int): Unit = {
    injected_suite_count.set(count)
  }

  /** Returns time and [[com.guidewire.tarot.SuiteKind]] of each (virtual) suite entering
    * the queue
    *
    * The suites themselves are not created; only the information on their
    * arrivals are produced.
    *
    * The suite arrivals are generated by a provided series of integers.
    *
    * @param interval Time within which suite arrivals are simulated
    */
  def apply(interval: Interval): Seq[(DateTime, UID[_])] = {
    assert(interval.toDurationMillis() >= 1L)
    val length: Double = (interval.toDurationMillis() - 1L).toDouble

    var next = 0
    var injected = injected_suite_count.getAndSet(0)

    lock.lock()
    try {
      if (iterator == null || !iterator.hasNext) {
        iterator = series.iterator
      }

      next = iterator.next()
    } finally {
      lock.unlock()
    }

    // The sampled number of suites that will appear in this interval
    for (_ <- 0 until next + injected)
    yield {
      // Pick a random point in the interval at which to queue the test suite
      val dur: Long = (config.random.nextDouble() * length).round
      val suiteTime = interval.getStart().plus(dur)

      (suiteTime, uid)
    }
  }
}
